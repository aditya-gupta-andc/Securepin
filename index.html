<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>EDD-3 Ghosi - Consumer Detail</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.5/xlsx.full.min.js"></script>
  <style>
    :root {
      --primary-color: #2563eb;
      --secondary-color: #1e40af;
      --background: #f8fafc;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 15px;
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      min-height: 100vh;
      -webkit-text-size-adjust: 100%;
    }
    .container {
      background: white;
      padding: 1rem;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      margin: 0 auto;
      max-width: 100%;
    }
    h1 {
      color: var(--primary-color);
      text-align: center;
      margin: 1rem 0;
      font-size: 1.8rem;
      line-height: 1.3;
    }
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 0.8rem;
      margin-bottom: 1rem;
    }
    .led {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ccc;
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
    }
    .led.online {
      background: #4ade80;
      animation: pulse 1.5s infinite;
    }
    .led.offline {
      background: #ef4444;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.4); }
      70% { box-shadow: 0 0 0 8px rgba(74, 222, 128, 0); }
      100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
    }
    .progress-container {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
      margin: 1rem 0;
      display: none;
    }
    .progress-bar {
      height: 100%;
      background: #2563eb;
      border-radius: 4px;
      transition: width 0.3s ease;
    }
    .progress-text {
      text-align: center;
      font-size: 0.9rem;
      color: #64748b;
      margin-top: 0.5rem;
    }
    .search-box {
      position: relative;
      margin-bottom: 1.5rem;
    }
    input {
      width: 100%;
      padding: 0.8rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 16px;
      -webkit-appearance: none;
    }
    button {
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 6px;
      touch-action: manipulation;
      cursor: pointer;
    }
    .search-box button {
      position: absolute;
      right: 4px;
      top: 4px;
    }
    .autocomplete-items {
      position: absolute;
      border: 1px solid #e2e8f0;
      border-top: none;
      z-index: 99;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 50vh;
      overflow-y: auto;
      background: white;
    }
    .autocomplete-item {
      padding: 12px;
      font-size: 15px;
      line-height: 1.4;
      cursor: pointer;
    }
    .result {
      margin-top: 1.5rem;
      padding: 1rem;
      border-radius: 8px;
      background: white;
      border: 1px solid #e2e8f0;
      font-size: 14px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    td {
      padding: 10px;
      border-bottom: 1px solid #e2e8f0;
      word-break: break-word;
    }
    td:first-child {
      font-weight: 500;
      color: var(--primary-color);
      width: 45%;
      min-width: 100px;
    }
    .loading {
      text-align: center;
      padding: 1.5rem;
      font-size: 1rem;
    }
    .error {
      font-size: 14px;
      padding: 12px;
      color: #dc2626;
    }
    @media screen and (max-width: 480px) {
      body {
        padding: 10px;
      }
      .container {
        padding: 0.8rem;
      }
      h1 {
        font-size: 1.6rem;
      }
      td {
        padding: 8px;
        font-size: 13px;
      }
      button {
        padding: 0.4rem 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîç Consumer Detail</h1>
    <div class="status-indicator">
      <div class="led" id="status-led"></div>
      <span id="connection-status">Checking connection...</span>
    </div>
    <div class="progress-container" id="progress-container">
      <div class="progress-bar" id="progress-bar"></div>
    </div>
    <div class="progress-text" id="progress-text"></div>
    <div class="data-controls">
      <button onclick="refreshData()">‚ü≥ Refresh Data</button>
      <span id="data-status" class="data-status"></span>
    </div>
    <div class="search-box">
      <input type="text" id="consumerId" placeholder="Search Consumer ID or Name..." />
      <!-- The button text will toggle between "Search" and "Clear" -->
      <button id="search-btn" onclick="searchConsumer()">Search</button>
      <div id="autocomplete-list" class="autocomplete-items"></div>
    </div>
    <div id="loading" class="loading">Loading consumer data</div>
    <div id="result" class="result"></div>
  </div>

  <script>
    // Global variables:
    // offlineConsumers: minimal data (ACCT_ID, NAME, JAN_READ_REMARK, JAN_BILL_BASIS) stored offline.
    // fullConsumerData: full details (available only when online, stored in memory).
    let offlineConsumers = [];
    let fullConsumerData = {};
    const excelUrl = "https://raw.githubusercontent.com/aditya-gupta-andc/webpage/55759f90d38bd10804e22e5603dbd38131f767fb/master25.xlsx";
    const DB_NAME = 'ConsumerDB';
    const STORE_NAME = 'consumerCache';
    const CACHE_KEY = 'cachedData';

    // IndexedDB Management (stores only minimal offline data)
    async function initDB() {
      return new Promise((resolve, reject) => {
        if (!window.indexedDB) {
          reject(new Error("Browser doesn't support IndexedDB"));
          return;
        }
        const request = indexedDB.open(DB_NAME, 3);
        request.onerror = (event) => {
          reject(new Error(`Database error: ${event.target.error}`));
        };
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
            store.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
      });
    }

    async function getCachedData() {
      try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, 'readonly');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.get(CACHE_KEY);
          request.onsuccess = () => resolve(request.result ? request.result.data : null);
          request.onerror = () => reject(request.error);
        });
      } catch (error) {
        console.error('Cache retrieval error:', error);
        return null;
      }
    }

    async function storeCachedData(data) {
      try {
        const db = await initDB();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const entry = {
            id: CACHE_KEY,
            data: data,
            timestamp: Date.now()
          };
          const request = store.put(entry);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      } catch (error) {
        console.error('Cache storage error:', error);
      }
    }

    // Progress management
    function updateProgress(percentage, message) {
      const progressBar = document.getElementById('progress-bar');
      const progressContainer = document.getElementById('progress-container');
      const progressText = document.getElementById('progress-text');
      progressBar.style.width = `${percentage}%`;
      progressText.textContent = message;
      progressContainer.style.display = 'block';
      if (percentage >= 100) {
        setTimeout(() => {
          progressContainer.style.display = 'none';
          progressText.textContent = '';
        }, 1000);
      }
    }

    // Data Loading: if online, fetch and process full Excel; if offline, load from cache.
    async function loadData() {
      try {
        // Try to load cached minimal data (offlineConsumers)
        const cached = await getCachedData();
        if (cached) {
          offlineConsumers = cached.offlineConsumers;
          updateDataStatus(cached.timestamp);
        }
        if (navigator.onLine) {
          await fetchData();
        } else {
          hideLoading();
          showError('No internet connection. Full consumer details are not available.');
        }
      } catch (error) {
        showError(`Initialization error: ${error.message}`);
      }
    }

    // Fetch full data (when online) but store only minimal info offline.
    async function fetchData() {
      try {
        showLoading();
        updateProgress(10, "Starting download...");
        const response = await fetch(excelUrl);
        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
        const reader = response.body.getReader();
        const contentLength = +response.headers.get('Content-Length');
        let receivedLength = 0;
        const chunks = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
          receivedLength += value.length;
          if (contentLength) {
            const percent = Math.round((receivedLength / contentLength) * 100);
            updateProgress(10 + (percent * 0.8), `Downloading... ${percent}%`);
          }
        }
        updateProgress(90, "Processing data...");
        // Merge chunks into one ArrayBuffer
        const merged = new Uint8Array(chunks.reduce((acc, chunk) => acc.concat(Array.from(chunk)), []));
        const arrayBuffer = merged.buffer;
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
        const headers = jsonData.shift();

        // Reset data arrays
        offlineConsumers = [];
        fullConsumerData = {};

        // Build the full data and the minimal offline cache
        // (store only ACCT_ID, NAME, JAN_READ_REMARK, JAN_BILL_BASIS)
        jsonData.forEach(row => {
          let consumer = {};
          headers.forEach((key, index) => {
            consumer[key] = row[index] ?? '';
          });
          const id = consumer.ACCT_ID ? consumer.ACCT_ID.toString() : '';
          const name = consumer.NAME || 'N/A';
          const jan_read_remark = consumer.JAN_READ_REMARK || '';
          const jan_bill_basis = consumer.JAN_BILL_BASIS || '';
          if (id) {
            offlineConsumers.push({ id, name, jan_read_remark, jan_bill_basis });
            fullConsumerData[id] = consumer;
          }
        });

        updateProgress(95, "Storing minimal data...");
        await storeCachedData({
          offlineConsumers: offlineConsumers,
          timestamp: Date.now()
        });
        updateProgress(100, "Data loaded successfully!");
        hideLoading();
        updateDataStatus(Date.now());
      } catch (error) {
        updateProgress(0, "Loading failed!");
        const cached = await getCachedData();
        if (cached) {
          offlineConsumers = cached.offlineConsumers;
          updateDataStatus(cached.timestamp);
        }
        showError(error.message);
      }
    }

    // UI Functions
    function updateOnlineStatus() {
      const isOnline = navigator.onLine;
      const led = document.getElementById('status-led');
      const statusText = document.getElementById('connection-status');
      led.className = `led ${isOnline ? 'online' : 'offline'}`;
      statusText.textContent = isOnline ? 'Online' : 'Offline';
      statusText.style.color = isOnline ? '#4ade80' : '#ef4444';
    }

    function updateDataStatus(timestamp) {
      const date = new Date(timestamp);
      document.getElementById('data-status').textContent =
        `Last updated: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
    }

    function showLoading() {
      document.getElementById('loading').style.display = 'block';
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    function showError(message) {
      const resultDiv = document.getElementById('result');
      resultDiv.innerHTML = `<div class="error">${message}</div>`;
    }

    // Search Functions
    // Debounce function to limit autocomplete frequency
    function debounce(func, timeout = 300) {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => func.apply(this, args), timeout);
      };
    }

    // Show autocomplete suggestions from the cached minimal data.
    function showAutocomplete() {
      const inputVal = document.getElementById('consumerId').value.toLowerCase();
      const autocompleteList = document.getElementById('autocomplete-list');
      autocompleteList.innerHTML = '';
      if (!inputVal) return;
      const matches = offlineConsumers.filter(consumer =>
        (consumer.id && consumer.id.includes(inputVal)) ||
        (consumer.name && consumer.name.toLowerCase().includes(inputVal))
      ).slice(0, 5);
      matches.forEach(consumer => {
        const div = document.createElement('div');
        div.className = 'autocomplete-item';
        div.innerHTML = `
          <div><strong>${consumer.id}</strong></div>
          <div style="color: #64748b; font-size: 0.9rem">${consumer.name}</div>
        `;
        div.onclick = () => {
          document.getElementById('consumerId').value = consumer.id;
          autocompleteList.innerHTML = '';
          searchConsumer();
        };
        autocompleteList.appendChild(div);
      });
    }

    // Search for a consumer.
    // If called with autoUpdate=true (on online event), then the function bypasses the "Clear" check.
    function searchConsumer(autoUpdate = false) {
      const btn = document.getElementById('search-btn');
      // If not autoUpdate and the button shows "Clear", then clear the search record.
      if (!autoUpdate && btn.textContent === 'Clear') {
        document.getElementById('consumerId').value = '';
        document.getElementById('result').innerHTML = '';
        btn.textContent = 'Search';
        return;
      }
      
      const consumerId = document.getElementById('consumerId').value.trim();
      const resultDiv = document.getElementById('result');
      resultDiv.innerHTML = '';

      if (!consumerId) {
        resultDiv.innerHTML = '<div class="error">Please enter a Consumer ID</div>';
        return;
      }

      if (navigator.onLine) {
        // When online, show full consumer details.
        const consumer = fullConsumerData[consumerId];
        if (consumer) {
          let html = '<h3 style="margin-bottom: 1rem; color: var(--primary-color)">Consumer Details</h3>';
          html += '<table>';
          Object.entries(consumer).forEach(([key, value]) => {
            if (value) html += `<tr><td>${key}</td><td>${value}</td></tr>`;
          });
          html += '</table>';
          resultDiv.innerHTML = html;
          btn.textContent = 'Clear';
        } else {
          resultDiv.innerHTML = `<div class="error">Consumer ID "${consumerId}" not found</div>`;
        }
      } else {
        // When offline, show only the cached minimal data.
        const consumer = offlineConsumers.find(c => c.id === consumerId);
        if (consumer) {
          resultDiv.innerHTML = `<div class="error">You are offline. Full consumer details are available only when online. Showing cached data:</div>
            <div><strong>ID:</strong> ${consumer.id}</div>
            <div><strong>Name:</strong> ${consumer.name}</div>
            <div><strong>JAN_READ_REMARK:</strong> ${consumer.jan_read_remark}</div>
            <div><strong>JAN_BILL_BASIS:</strong> ${consumer.jan_bill_basis}</div>`;
          btn.textContent = 'Clear';
        } else {
          resultDiv.innerHTML = `<div class="error">Consumer ID "${consumerId}" not found in cached data</div>`;
        }
      }
    }

    // Refresh data button (only works when online)
    async function refreshData() {
      if (!navigator.onLine) {
        alert('Cannot refresh while offline');
        return;
      }
      try {
        document.getElementById('data-status').textContent = 'Updating data...';
        await fetchData();
      } catch (error) {
        showError(`Refresh failed: ${error.message}`);
      }
    }

    // Initialization
    document.addEventListener('DOMContentLoaded', async () => {
      window.addEventListener('online', () => {
        updateOnlineStatus();
        // If there is a search result (button text is "Clear") and a consumer is entered,
        // automatically update the result to show full details.
        const consumerId = document.getElementById('consumerId').value.trim();
        if (consumerId && document.getElementById('search-btn').textContent === 'Clear') {
          searchConsumer(true);
        }
      });
      window.addEventListener('offline', updateOnlineStatus);
      updateOnlineStatus();
      try {
        await initDB();
        await loadData();
        document.getElementById('consumerId').addEventListener('input', debounce(showAutocomplete));
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.search-box')) {
            document.getElementById('autocomplete-list').innerHTML = '';
          }
        });
      } catch (error) {
        showError(`Initialization failed: ${error.message}`);
      }
    });
  </script>
</body>
</html>
